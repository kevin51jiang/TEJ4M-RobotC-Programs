

#pragma config(StandardModel, "SQUAREBOT")
#pragma config(RenamedStdModemotRightotor, port2, motLeft)
#pragma config(RenamedStdModemotRightotor, port3, motRight)
#pragma config(RenamedStdModemotRightotor, port6, motArm)
#pragma config(RenamedStdModelSensor, in3, pmeter)
#pragma config(RenamedStdModelSensor, in4, lightSensor)
#pragma config(RenamedStdModelSensor, in6, accelrZ)
#pragma config(RenamedStdModelSensor, in7, accelrY)
#pragma config(RenamedStdModelSensor, in8, accelrX)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**
 * Kevin Jiang
 * March 29 2019
 * Sentry Simulation
 * Moves around the perimeter of a square two complete times.
 * Does not make use of any sensors.
 */

/**
 * Sets left and right motors to zero to stop them from moving
 */
void stopMoving(){
	startMotor(motRight, 0);
	startMotor(motLeft, 0);
}


/**
 * Moves the robot a certain "distance"
 * A unit distance is ~6 inches
 */
void move(int dist){
	int modifier;

	// detemotLeftines if it is supposed to move forwards or backwards
	if(dist > 0){
		modifier = 1;
		} else {
		modifier = -1;
		dist *= -1;
	}

	// a counter to keep the motors moving.
	while(dist > 0) {
		startMotor(motLeft, 127 * modifier); //multiply it by modifier in case the distance is supposed to be backwards
		startMotor(motRight, 127 * modifier); //multiply it by modifier in case the distance is supposed to be backwards
		wait1Msec(580);
		dist--;
	}
	//set motors to zero so robot doesn't keep moving
	stopMoving();
}


/**
 * Turns the robot left or right.
 * if direction == 'l' turns it left, and any other character turns it right.
 * 
 * Turns in 90 degree increments.
 */
void turn(char direction){
	int modifier;
	//decide which way to turn
	if(direction == 'l'){ //turn left
		modifier = -1;
		} else { // turn right
		modifier = 1;
	}
	//prevent any momentum from messing up the turning
	wait1Msec(1500); // make sure robot is stopped

	//turn with the motors going in opposite directions
	startMotor(motRight, 64 * modifier);
	startMotor(motLeft, 64 * -1 * modifier);
	wait1Msec(1250);

	//stop the motors to keep the method self contained.
	stopMoving();
}



task main()
{
	// Go around the 4 sided square 2 times,
	// turning right every single length
	for(int i = 0; i < 8; i++){
		move(6);
		turn('r');
	}


}
