#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in2,    midLine,        sensorLineFollower)
#pragma config(Sensor, in3,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, in6,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           motRight,      tmotorVex393_MC29, openLoop, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           motLeft,       tmotorVex393_MC29, openLoop, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port6,           motArm,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(DatalogSeries, 0, "LeftFollow", Sensors, Sensor, in1, 50)
#pragma config(DatalogSeries, 1, "MidFollow", Sensors, Sensor, in2, 50)
#pragma config(DatalogSeries, 2, "RightFollow", Sensors, Sensor, in3, 50)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int baseSpeed = 20;
const int deltaVal = 3;//when moving, both options will be modified by +- the deltaVal
const int topSpeed = 30;
bool isTurnLeft = true;

//gets rid of arm so squarebot is more square
task getRidOfArm(){
	startMotor(motArm, -127);
	wait1Msec(1250);
	stopMotor(motArm);
}

//resets the motor speed to the base speed
void resetMotors(){
	motor[motRight] = baseSpeed;
	motor[motLeft] = baseSpeed;
}


//
//
//
float controlLeft() {
	float percentageErr;
	if(SensorValue[leftLine] < 2000) {
		percentageErr = (2000 - SensorValue[rightLine]) / 2000;
		writeDebugStreamLine("%Err L: %d", percentageErr);


		motor[motLeft] = percentageErr * topSpeed;//set it proportional to what it lacks

		if(percentageErr > 0.5) {
			motor[motRight] -= 1;
		}

	} else {
		motor[motLeft] = baseSpeed - 3;
	}
	wait1Msec(25);
	return percentageErr;
}




//
// M A I N
//
task main()
{
	dataLogClear();
	startTask(getRidOfArm);
	motor[motRight] = 30;
	motor[motLeft] = 30;
	wait1Msec(250);

	//steps
	/*
		1. Normalize the sensor values (go on a scale from 1-100, when the readings go from 0 - 2500)
		2. These are the following cases:
				a) All 3 values are the same - go forward
				b) The side values are the same, and the center value is the highest - go forward
				c) One edge is lower than the other 2 - increase power to that motor
				d) One side is higher than mid & other side - decrease power to that motor, slight increase to slower side

	*/



	while(true) {

		wait1Msec(250);
		if(SensorValue[midLine] < 2000){
			int leftPercErr = round(100 * controlLeft());
			int rightPercErr = round(100 * controlRight());

			if(abs(leftPercErr - rightPercErr) < 5) { // if there's less than a 10% discrepancy between the errors, go forward
				stopMotors();
			}

		}

		/*
		dataLogClear();
		datalogDataGroupStart();
		datalogAddValue(0, SensorValue(leftLine));
		datalogAddValue(1, SensorValue(midLine));
		datalogAddValue(2, SensorValue(rightLine));
		datalogDataGroupEnd();
		/*
				while(SensorValue[rightLine] >= 1600) {
					wait1Msec(25);
				}
				if(isTurnLeft) {
					motor[motLeft] = baseSpeed - 5
					motor[motRight] = baseSpeed + 5;
					while(SensorValue[rightLine] < 1700) {
						wait1Msec(5);
					}

				} else {
					motor[motRight] = baseSpeed - 5;
					motor[motLeft] = baseSpeed + 5;
					while(SensorValue[rightLine] < 1700) {
						wait1Msec(5);
					}
				}



				isTurnLeft = !isTurnLeft;
				stopMotors();
				wait1Msec(100);
		*/
	}
}
